"use strict";

var _interopRequire = function (obj) { return obj && obj.__esModule ? obj["default"] : obj; };

var _createClass = (function () { function defineProperties(target, props) { for (var key in props) { var prop = props[key]; prop.configurable = true; if (prop.value) prop.writable = true; } Object.defineProperties(target, props); } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _classCallCheck = function (instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } };

var cheerio = _interopRequire(require("cheerio"));

var Logger = _interopRequire(require("color-logger"));

/** @ignore */
var logger = new Logger("IceCap");

/**
 * @class
 * @classdesc IceCap process HTML template with programmable.
 * @fileexample
 * import IceCap from 'ice-cap';
 * let ice = new IceCap('<p data-ice="name"></p>');
 * ice.text('name', 'Alice');
 * console.log(ice.html); // <p data-ice="name">Alice</p>
 */

var IceCap = (function () {

  /**
   * create instance with HTML template.
   * @param {!string} html
   * @param {Object} [options]
   * @param {boolean} [options.autoDrop=true]
   * @param {boolean} [options.autoClose=true]
   */

  function IceCap(html) {
    var _ref = arguments[1] === undefined ? { autoClose: true, autoDrop: true } : arguments[1];

    var _ref$autoClose = _ref.autoClose;
    var autoClose = _ref$autoClose === undefined ? true : _ref$autoClose;
    var _ref$autoDrop = _ref.autoDrop;
    var autoDrop = _ref$autoDrop === undefined ? true : _ref$autoDrop;

    _classCallCheck(this, IceCap);

    if (!html) {
      throw new Error("html must be specified.");
    }

    if (typeof html === "string") {
      this._$root = cheerio.load(html).root();
    } else if (html.find) {
      this._$root = html;
    }
    this._options = { autoClose: autoClose, autoDrop: autoDrop };
  }

  _createClass(IceCap, {
    autoDrop: {
      set: function (val) {
        this._options.autoDrop = val;
      },
      get: function () {
        return this._options.autoDrop;
      }
    },
    autoClose: {
      set: function (val) {
        this._options.autoClose = val;
      },
      get: function () {
        return this._options.autoClose;
      }
    },
    text: {

      /**
       * apply value to DOM that is specified with id.
       * @param {!string} id
       * @param {string} value
       * @param {string} [mode=IceCap.MODE_APPEND]
       * @return {IceCap} self instance.
       */

      value: function text(id, value) {
        var mode = arguments[2] === undefined ? this.constructor.MODE_APPEND : arguments[2];

        var nodes = this._nodes(id);

        if (this._options.autoDrop && !value) {
          nodes.remove();
          return;
        }

        if (value === null || value === undefined) value = "";

        var transformedValue = undefined;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nodes.iterator[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            var currentValue = node.text() || "";
            switch (mode) {
              case this.constructor.MODE_WRITE:
                transformedValue = value;
                break;
              case this.constructor.MODE_APPEND:
                transformedValue = currentValue + value;
                break;
              case this.constructor.MODE_REMOVE:
                transformedValue = currentValue.replace(new RegExp(value, "g"), "");
                break;
              case this.constructor.MODE_PREPEND:
                transformedValue = value + currentValue;
                break;
              default:
                throw Error("unknown mode. mode = \"" + mode + "\"");
            }

            node.text(transformedValue);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return this;
      }
    },
    load: {
      value: function load(id, ice) {
        var mode = arguments[2] === undefined ? this.constructor.MODE_APPEND : arguments[2];

        var html = "";
        if (ice instanceof IceCap) {
          html = ice.html;
        } else if (ice) {
          html = ice.toString();
        }

        var nodes = this._nodes(id);

        if (this._options.autoDrop && !html) {
          nodes.remove();
          return;
        }

        nodes.attr("data-ice-loaded", "1");
        var transformedValue = undefined;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nodes.iterator[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            var currentValue = node.html() || "";
            switch (mode) {
              case this.constructor.MODE_WRITE:
                node.text("");
                transformedValue = html;
                break;
              case this.constructor.MODE_APPEND:
                transformedValue = currentValue + html;
                break;
              case this.constructor.MODE_REMOVE:
                transformedValue = currentValue.replace(new RegExp(html, "g"), "");
                break;
              case this.constructor.MODE_PREPEND:
                transformedValue = html + currentValue;
                break;
              default:
                throw Error("unknown mode. mode = \"" + mode + "\"");
            }

            node.html(transformedValue);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return this;
      }
    },
    attr: {
      value: function attr(id, key, value) {
        var mode = arguments[3] === undefined ? this.constructor.MODE_APPEND : arguments[3];

        var nodes = this._nodes(id);
        var transformedValue;

        if (value === null || value === undefined) value = "";

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nodes.iterator[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            var currentValue = node.attr(key) || "";
            switch (mode) {
              case this.constructor.MODE_WRITE:
                transformedValue = value;
                break;
              case this.constructor.MODE_APPEND:
                transformedValue = currentValue + value;
                break;
              case this.constructor.MODE_REMOVE:
                transformedValue = currentValue.replace(new RegExp(value, "g"), "");
                break;
              case this.constructor.MODE_PREPEND:
                transformedValue = value + currentValue;
                break;
              default:
                throw Error("unknown mode. mode = \"" + mode + "\"");
            }

            node.attr(key, transformedValue);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return this;
      }
    },
    loop: {
      value: function loop(id, values, callback) {
        if (!Array.isArray(values)) {
          throw new Error("values must be array. values = \"" + values + "\"");
        }

        if (["function", "string"].indexOf(typeof callback) === -1) {
          throw new Error("callback must be function. callback = \"" + callback + "\"");
        }

        if (typeof callback === "string") {
          switch (callback) {
            case this.constructor.CALLBACK_TEXT:
              callback = function (i, value, ice) {
                return ice.text(id, value);
              };
              break;
            case this.constructor.CALLBACK_LOAD:
              callback = function (i, value, ice) {
                return ice.load(id, value);
              };
              break;
            default:
              throw Error("unknown callback. callback = \"" + callback + "\"");
          }
        }

        var nodes = this._nodes(id);

        if (values.length === 0) {
          nodes.remove();
          return;
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nodes.iterator[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            var results = [];
            for (var j = 0; j < values.length; j++) {
              var _parent = cheerio.load("<div/>").root();
              var clonedNode = node.clone();
              var textNode = cheerio.load("\n").root();

              _parent.append(clonedNode);
              results.push(clonedNode[0]);
              results.push(textNode[0]);

              var ice = new IceCap(_parent);
              callback(j, values[j], ice);
            }

            if (node.parent().length) {
              node.parent().append(results);
            } else {
              this._$root.append(results);
            }
            node.remove();
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return this;
      }
    },
    into: {
      value: function into(id, value, callback) {
        var nodes = this._nodes(id);

        if (value === "" || value === null || value === undefined) {
          nodes.remove();
          return;
        } else if (Array.isArray(value)) {
          if (value.length === 0) {
            nodes.remove();
            return;
          }
        }

        if (typeof callback !== "function") {
          throw new Error("callback must be function. callback = \"" + callback + "\"");
        }

        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = nodes.iterator[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var node = _step.value;

            var ice = new IceCap(node);
            callback(value, ice);
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator["return"]) {
              _iterator["return"]();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return this;
      }
    },
    drop: {
      value: function drop(id) {
        var isDrop = arguments[1] === undefined ? true : arguments[1];

        if (!isDrop) {
          return;
        }var nodes = this._nodes(id);
        nodes.remove();

        return this;
      }
    },
    close: {
      value: function close() {
        if (!this._$root) {
          return this;
        }this._html = this._takeHTML();
        this._$root = null;
        return this;
      }
    },
    html: {
      get: function () {
        if (!this._$root) return this._html;

        this._html = this._takeHTML();

        if (this._options.autoClose) {
          this.close();
        }

        return this._html;
      }
    },
    _nodes: {
      value: function _nodes(id) {
        if (!this._$root) throw new Error("can not operation after close.");
        if (!id) throw new Error("id must be specified.");

        var $nodes = this._$root.find("[data-ice=\"" + id + "\"]");

        var filtered = this._filter($nodes);

        if (filtered.length === 0 && this.constructor._debug) logger.w("node not found. id = " + id);

        return filtered;
      }
    },
    _filter: {
      value: function _filter(nodes) {
        var results = [];
        for (var i = 0; i < nodes.length; i++) {
          var node = nodes.eq(i);
          var _length = node.parents("[data-ice-loaded]").length;
          if (_length === 0) {
            results.push(node[0]);
          }
        }

        var $result = cheerio(results);

        Object.defineProperty($result, "iterator", {
          get: function get() {
            var nodes = [];
            for (var i = 0; i < this.length; i++) {
              nodes.push(this.eq(i));
            }
            return nodes;
          }
        });

        return $result;
      }
    },
    _takeHTML: {
      value: function _takeHTML() {
        var loadedNodes = this._$root.find("[data-ice-loaded]").removeAttr("data-ice-loaded");

        var html = this._$root.html();

        loadedNodes.attr("data-ice-loaded", 1);

        return html;
      }
    }
  }, {
    MODE_APPEND: {
      get: function () {
        return "append";
      }
    },
    MODE_WRITE: {
      get: function () {
        return "write";
      }
    },
    MODE_REMOVE: {
      get: function () {
        return "remove";
      }
    },
    MODE_PREPEND: {
      get: function () {
        return "prepend";
      }
    },
    CALLBACK_TEXT: {
      get: function () {
        return "text";
      }
    },
    CALLBACK_LOAD: {
      get: function () {
        return "html";
      }
    },
    debug: {
      set: function (v) {
        this._debug = v;
      }
    }
  });

  return IceCap;
})();

module.exports = IceCap;